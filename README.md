# C++ 内存模型
将机器的内存看作是内存地址序列，这个序列可以放置对象，并通过指针访问对象。
对于赋值操作，只不过是机器的拷贝操作；

# C++ 计算模型
基于计算机硬件

# 组装code成程序的基本机制
C++是编译语言，原文本经由compiler处理，生成obejct files；再由linker合并成一个可执行的程序。
 可执行程序是为特定的系统或者硬件创建的。所以在说C++的可移植性，指的是源码的可移植性。
 
 # C++标准的两种实体：
  - Core 语言特性
  - 标准库组件
  
C++是静态类型的语言，实体的类型一定是要compiler知道的。对象的类型决定了它可以应用的操作。

Linux会使用main函数的返回值；但是windows很少使用。

每一个c++程序必须要有一个全局的main函数。



可维护性
- 将计算任务拆分成有意义的小块并加以命名
- 

C++ 会在基本类型之间执行转换；表达式执行的顺序是左到右，但是函数参数的执行顺序未指定。

对于=和{}花括号的初始化，=允许在多位向低位转换的时候，丢失精度；但是{}不允许隐式转换和丢失精度。



auto一般使用在两种特殊原因:
1. 定义在很大的范围内，想要读者更清楚code
2. 显示的表明变量的范围和精度(特别是泛型编程里，对象的类型很难清楚的知道而且类型也可能很长)

auto类型可以避免冗余和书写长类型名字


C++的作用域
1. local scope
2. class scope
3. Namespace scope, 一个比较特殊的叫做global

一个对象会在使用前被创建初始化，在他的作用域末端被清除。

对于命名空间里的对象，则会在程序运行的末端被清除。

成员的销毁事件是在包含成员的对象被销毁的时候。

new创建的对象一直存活到delete销毁的时候。


C++支持两种immutability的概念
1. const 用于指定interface，表明使用指针或者引用传递的数据，不用担心被修改

2. constexpr (const expression)指的是在编译时执行，允许放在read-only的内存里进行数据占位。

constant expression  是语言规则需要的。

引用和指针都引用或指向一个对象，都是代表着内存的地址。但是使用规则是不一样的。给引用赋值不会改变引用的值，但是会改变引用指向对象

访问指针指的值需要使用*，但是访问引用就能直接拿到指向的对象

在表达式中，前缀*是指的内容。前缀&是地址
``` c++
    char* p = ** &cs[3]**;
    char xx = ** *p **;
```

&引用在指定函数参数的时候，特别有用；还有在遍历的时候，不需要拷贝值，性能更好。

在初始化指针的时候，可以使用nullptr；实践中最好事先减产指针是否为nullptr。

引用不会改变；赋值给引用不会改变引用，而是会改变被引用的对象；
指针是对象的地址；




# 最佳实践
1. 不要专门或者独立使用内置的特性。内置的特性最好通过标准库间接的使用
2. 专注于编程技术而不是特性
3. 当函数根据不同的类型执行同一个任务的时候，使用重载函数
4. 如果函数必须在编译时执行，用constexpr 声明
5. 使用数字隔离符号来让大字面量可读
6. 避免复杂表达式
7. 避免窄转换
8. 最小化变量的作用域
9. 保持通用名和本地名尽可能的短，不常用全局的名字尽可能的长
10. 优先使用{} 初始化
11. unsigned只用于位操作
12. 使用auto避免反复的类型名字





